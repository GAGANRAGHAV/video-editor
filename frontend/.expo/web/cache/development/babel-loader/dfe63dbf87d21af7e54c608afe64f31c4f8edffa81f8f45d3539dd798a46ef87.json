{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { API_ENDPOINTS } from \"./config\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nvar FileSystem;\nif (Platform.OS !== 'web') {\n  FileSystem = require('expo-file-system');\n}\nexport var uploadVideo = function () {\n  var _ref = _asyncToGenerator(function* (videoSource) {\n    var overlays = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    try {\n      var formData = new FormData();\n      if (Platform.OS === 'web') {\n        if (videoSource instanceof File) {\n          formData.append('video', videoSource);\n        } else if (typeof videoSource === 'string' && videoSource.startsWith('blob:')) {\n          var _response = yield fetch(videoSource);\n          var blob = yield _response.blob();\n          formData.append('video', blob, 'video.mp4');\n        } else {\n          throw new Error('Invalid video source for web platform');\n        }\n      } else {\n        if (!FileSystem) {\n          throw new Error('FileSystem not available');\n        }\n        var fileInfo = yield FileSystem.getInfoAsync(videoSource);\n        if (!fileInfo.exists) {\n          throw new Error('Video file does not exist');\n        }\n        var fileName = videoSource.split('/').pop() || 'video.mp4';\n        formData.append('video', {\n          uri: videoSource,\n          name: fileName,\n          type: 'video/mp4'\n        });\n      }\n      formData.append('overlays_json', JSON.stringify(overlays));\n      var response = yield fetch(API_ENDPOINTS.UPLOAD, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        var errorMessage = \"Upload failed with status: \" + response.status;\n        try {\n          var errorData = yield response.json();\n          errorMessage = errorData.detail || errorData.message || errorMessage;\n        } catch (e) {\n          var errorText = yield response.text();\n          errorMessage = errorText || errorMessage;\n        }\n        throw new Error(errorMessage);\n      }\n      var result = yield response.json();\n      console.log('Upload successful:', result);\n      return result;\n    } catch (error) {\n      console.error('Error uploading video:', error);\n      throw new Error(\"Upload failed: \" + error.message);\n    }\n  });\n  return function uploadVideo(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var checkJobStatus = function () {\n  var _ref2 = _asyncToGenerator(function* (jobId) {\n    try {\n      if (!jobId) {\n        throw new Error('Job ID is required');\n      }\n      var response = yield fetch(API_ENDPOINTS.STATUS(jobId), {\n        method: 'GET',\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        var errorMessage = \"Status check failed with status: \" + response.status;\n        try {\n          var errorData = yield response.json();\n          errorMessage = errorData.detail || errorData.message || errorMessage;\n        } catch (e) {\n          var errorText = yield response.text();\n          errorMessage = errorText || errorMessage;\n        }\n        throw new Error(errorMessage);\n      }\n      var result = yield response.json();\n      console.log('Status check result:', result);\n      return result;\n    } catch (error) {\n      console.error('Error checking job status:', error);\n      throw new Error(\"Status check failed: \" + error.message);\n    }\n  });\n  return function checkJobStatus(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var downloadVideo = function () {\n  var _ref3 = _asyncToGenerator(function* (jobId) {\n    var destinationUri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    try {\n      if (!jobId) {\n        throw new Error('Job ID is required');\n      }\n      if (Platform.OS === 'web') {\n        var response = yield fetch(API_ENDPOINTS.RESULT(jobId));\n        if (!response.ok) {\n          throw new Error(\"Download failed with status: \" + response.status);\n        }\n        var blob = yield response.blob();\n        var url = window.URL.createObjectURL(blob);\n        var link = document.createElement('a');\n        link.href = url;\n        link.download = \"processed_video_\" + jobId + \".mp4\";\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url);\n        return {\n          uri: url,\n          status: 'completed'\n        };\n      } else {\n        if (!FileSystem) {\n          throw new Error('FileSystem not available');\n        }\n        var finalDestinationUri = destinationUri || FileSystem.documentDirectory + \"processed_video_\" + jobId + \".mp4\";\n        var downloadResumable = FileSystem.createDownloadResumable(API_ENDPOINTS.RESULT(jobId), finalDestinationUri, {\n          headers: {\n            'Accept': 'video/mp4'\n          }\n        });\n        var result = yield downloadResumable.downloadAsync();\n        console.log('Download completed:', result);\n        return result;\n      }\n    } catch (error) {\n      console.error('Error downloading video:', error);\n      throw new Error(\"Download failed: \" + error.message);\n    }\n  });\n  return function downloadVideo(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var getVideoInfo = function () {\n  var _ref4 = _asyncToGenerator(function* (videoSource) {\n    try {\n      if (Platform.OS === 'web') {\n        if (videoSource instanceof File) {\n          return {\n            exists: true,\n            size: videoSource.size,\n            name: videoSource.name,\n            type: videoSource.type\n          };\n        } else if (typeof videoSource === 'string' && videoSource.startsWith('blob:')) {\n          return {\n            exists: true,\n            uri: videoSource\n          };\n        }\n        return {\n          exists: false\n        };\n      } else {\n        if (!FileSystem) {\n          throw new Error('FileSystem not available');\n        }\n        return yield FileSystem.getInfoAsync(videoSource);\n      }\n    } catch (error) {\n      console.error('Error getting video info:', error);\n      return {\n        exists: false,\n        error: error.message\n      };\n    }\n  });\n  return function getVideoInfo(_x4) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nexport var cancelJob = function () {\n  var _ref5 = _asyncToGenerator(function* (jobId) {\n    try {\n      if (!jobId) {\n        throw new Error('Job ID is required');\n      }\n      var response = yield fetch(API_ENDPOINTS.CANCEL ? API_ENDPOINTS.CANCEL(jobId) : API_ENDPOINTS.STATUS(jobId) + \"/cancel\", {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(\"Cancel failed with status: \" + response.status);\n      }\n      return yield response.json();\n    } catch (error) {\n      console.error('Error canceling job:', error);\n      throw new Error(\"Cancel failed: \" + error.message);\n    }\n  });\n  return function cancelJob(_x5) {\n    return _ref5.apply(this, arguments);\n  };\n}();\nexport var getJobHistory = function () {\n  var _ref6 = _asyncToGenerator(function* () {\n    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    try {\n      var response = yield fetch((API_ENDPOINTS.JOBS || API_ENDPOINTS.UPLOAD.replace('/upload', '/jobs')) + \"?limit=\" + limit + \"&offset=\" + offset, {\n        method: 'GET',\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(\"Failed to fetch job history: \" + response.status);\n      }\n      return yield response.json();\n    } catch (error) {\n      console.error('Error fetching job history:', error);\n      throw new Error(\"Failed to fetch job history: \" + error.message);\n    }\n  });\n  return function getJobHistory() {\n    return _ref6.apply(this, arguments);\n  };\n}();\nexport var validateVideoFile = function () {\n  var _ref7 = _asyncToGenerator(function* (videoSource) {\n    try {\n      var info = yield getVideoInfo(videoSource);\n      if (!info.exists) {\n        return {\n          valid: false,\n          error: 'Video file does not exist'\n        };\n      }\n      var maxSize = 100 * 1024 * 1024;\n      if (info.size && info.size > maxSize) {\n        return {\n          valid: false,\n          error: 'Video file is too large (max 100MB)'\n        };\n      }\n      if (Platform.OS === 'web' && info.type && !info.type.startsWith('video/')) {\n        return {\n          valid: false,\n          error: 'Selected file is not a video'\n        };\n      }\n      return {\n        valid: true,\n        info: info\n      };\n    } catch (error) {\n      return {\n        valid: false,\n        error: error.message\n      };\n    }\n  });\n  return function validateVideoFile(_x6) {\n    return _ref7.apply(this, arguments);\n  };\n}();\nexport var checkServerConnection = function () {\n  var _ref8 = _asyncToGenerator(function* () {\n    try {\n      var response = yield fetch(API_ENDPOINTS.HEALTH || API_ENDPOINTS.UPLOAD.replace('/upload', '/health'), {\n        method: 'GET',\n        timeout: 5000\n      });\n      return {\n        connected: response.ok,\n        status: response.status\n      };\n    } catch (error) {\n      return {\n        connected: false,\n        error: error.message\n      };\n    }\n  });\n  return function checkServerConnection() {\n    return _ref8.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["API_ENDPOINTS","Platform","FileSystem","OS","require","uploadVideo","_ref","_asyncToGenerator","videoSource","overlays","arguments","length","undefined","formData","FormData","File","append","startsWith","response","fetch","blob","Error","fileInfo","getInfoAsync","exists","fileName","split","pop","uri","name","type","JSON","stringify","UPLOAD","method","body","headers","ok","errorMessage","status","errorData","json","detail","message","e","errorText","text","result","console","log","error","_x","apply","checkJobStatus","_ref2","jobId","STATUS","_x2","downloadVideo","_ref3","destinationUri","RESULT","url","window","URL","createObjectURL","link","document","createElement","href","download","appendChild","click","removeChild","revokeObjectURL","finalDestinationUri","documentDirectory","downloadResumable","createDownloadResumable","downloadAsync","_x3","getVideoInfo","_ref4","size","_x4","cancelJob","_ref5","CANCEL","_x5","getJobHistory","_ref6","limit","offset","JOBS","replace","validateVideoFile","_ref7","info","valid","maxSize","_x6","checkServerConnection","_ref8","HEALTH","timeout","connected"],"sources":["D:/DEV/buttercutai_assignment/frontend/api.js"],"sourcesContent":["import { API_ENDPOINTS } from './config';\r\nimport { Platform } from 'react-native';\r\n\r\n// Platform-specific imports\r\nlet FileSystem;\r\nif (Platform.OS !== 'web') {\r\n  FileSystem = require('expo-file-system');\r\n}\r\n\r\n// Upload video with overlay metadata\r\nexport const uploadVideo = async (videoSource, overlays = []) => {\r\n  try {\r\n    const formData = new FormData();\r\n    \r\n    if (Platform.OS === 'web') {\r\n      // Web platform handling\r\n      if (videoSource instanceof File) {\r\n        // Direct File object\r\n        formData.append('video', videoSource);\r\n      } else if (typeof videoSource === 'string' && videoSource.startsWith('blob:')) {\r\n        // Blob URL - fetch and convert to blob\r\n        const response = await fetch(videoSource);\r\n        const blob = await response.blob();\r\n        formData.append('video', blob, 'video.mp4');\r\n      } else {\r\n        throw new Error('Invalid video source for web platform');\r\n      }\r\n    } else {\r\n      // Native platform handling\r\n      if (!FileSystem) {\r\n        throw new Error('FileSystem not available');\r\n      }\r\n      \r\n      // Check if file exists\r\n      const fileInfo = await FileSystem.getInfoAsync(videoSource);\r\n      if (!fileInfo.exists) {\r\n        throw new Error('Video file does not exist');\r\n      }\r\n      \r\n      // Get filename from URI\r\n      const fileName = videoSource.split('/').pop() || 'video.mp4';\r\n      \r\n      // Create file object for form data\r\n      formData.append('video', {\r\n        uri: videoSource,\r\n        name: fileName,\r\n        type: 'video/mp4',\r\n      });\r\n    }\r\n    \r\n    // Append overlays as JSON string\r\n    formData.append('overlays_json', JSON.stringify(overlays));\r\n    \r\n    // Send request with proper headers\r\n    const response = await fetch(API_ENDPOINTS.UPLOAD, {\r\n      method: 'POST',\r\n      body: formData,\r\n      headers: {\r\n        'Accept': 'application/json',\r\n        // Don't set Content-Type for FormData - browser/RN will set it automatically with boundary\r\n      },\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      let errorMessage = `Upload failed with status: ${response.status}`;\r\n      try {\r\n        const errorData = await response.json();\r\n        errorMessage = errorData.detail || errorData.message || errorMessage;\r\n      } catch (e) {\r\n        const errorText = await response.text();\r\n        errorMessage = errorText || errorMessage;\r\n      }\r\n      throw new Error(errorMessage);\r\n    }\r\n    \r\n    const result = await response.json();\r\n    console.log('Upload successful:', result);\r\n    return result;\r\n    \r\n  } catch (error) {\r\n    console.error('Error uploading video:', error);\r\n    throw new Error(`Upload failed: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Check job status with enhanced error handling\r\nexport const checkJobStatus = async (jobId) => {\r\n  try {\r\n    if (!jobId) {\r\n      throw new Error('Job ID is required');\r\n    }\r\n    \r\n    const response = await fetch(API_ENDPOINTS.STATUS(jobId), {\r\n      method: 'GET',\r\n      headers: {\r\n        'Accept': 'application/json',\r\n      },\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      let errorMessage = `Status check failed with status: ${response.status}`;\r\n      try {\r\n        const errorData = await response.json();\r\n        errorMessage = errorData.detail || errorData.message || errorMessage;\r\n      } catch (e) {\r\n        const errorText = await response.text();\r\n        errorMessage = errorText || errorMessage;\r\n      }\r\n      throw new Error(errorMessage);\r\n    }\r\n    \r\n    const result = await response.json();\r\n    console.log('Status check result:', result);\r\n    return result;\r\n    \r\n  } catch (error) {\r\n    console.error('Error checking job status:', error);\r\n    throw new Error(`Status check failed: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Download rendered video with platform-specific handling\r\nexport const downloadVideo = async (jobId, destinationUri = null) => {\r\n  try {\r\n    if (!jobId) {\r\n      throw new Error('Job ID is required');\r\n    }\r\n    \r\n    if (Platform.OS === 'web') {\r\n      // Web platform - trigger download\r\n      const response = await fetch(API_ENDPOINTS.RESULT(jobId));\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`Download failed with status: ${response.status}`);\r\n      }\r\n      \r\n      // Create download link\r\n      const blob = await response.blob();\r\n      const url = window.URL.createObjectURL(blob);\r\n      const link = document.createElement('a');\r\n      link.href = url;\r\n      link.download = `processed_video_${jobId}.mp4`;\r\n      document.body.appendChild(link);\r\n      link.click();\r\n      document.body.removeChild(link);\r\n      window.URL.revokeObjectURL(url);\r\n      \r\n      return { uri: url, status: 'completed' };\r\n      \r\n    } else {\r\n      // Native platform\r\n      if (!FileSystem) {\r\n        throw new Error('FileSystem not available');\r\n      }\r\n      \r\n      // Generate destination URI if not provided\r\n      const finalDestinationUri = destinationUri || \r\n        `${FileSystem.documentDirectory}processed_video_${jobId}.mp4`;\r\n      \r\n      const downloadResumable = FileSystem.createDownloadResumable(\r\n        API_ENDPOINTS.RESULT(jobId),\r\n        finalDestinationUri,\r\n        {\r\n          headers: {\r\n            'Accept': 'video/mp4',\r\n          },\r\n        }\r\n      );\r\n      \r\n      const result = await downloadResumable.downloadAsync();\r\n      console.log('Download completed:', result);\r\n      return result;\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error('Error downloading video:', error);\r\n    throw new Error(`Download failed: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Get video info (platform-specific)\r\nexport const getVideoInfo = async (videoSource) => {\r\n  try {\r\n    if (Platform.OS === 'web') {\r\n      if (videoSource instanceof File) {\r\n        return {\r\n          exists: true,\r\n          size: videoSource.size,\r\n          name: videoSource.name,\r\n          type: videoSource.type,\r\n        };\r\n      } else if (typeof videoSource === 'string' && videoSource.startsWith('blob:')) {\r\n        // For blob URLs, we can't get detailed info without fetching\r\n        return {\r\n          exists: true,\r\n          uri: videoSource,\r\n        };\r\n      }\r\n      return { exists: false };\r\n    } else {\r\n      if (!FileSystem) {\r\n        throw new Error('FileSystem not available');\r\n      }\r\n      return await FileSystem.getInfoAsync(videoSource);\r\n    }\r\n  } catch (error) {\r\n    console.error('Error getting video info:', error);\r\n    return { exists: false, error: error.message };\r\n  }\r\n};\r\n\r\n// Cancel job (if backend supports it)\r\nexport const cancelJob = async (jobId) => {\r\n  try {\r\n    if (!jobId) {\r\n      throw new Error('Job ID is required');\r\n    }\r\n    \r\n    const response = await fetch(API_ENDPOINTS.CANCEL ? API_ENDPOINTS.CANCEL(jobId) : `${API_ENDPOINTS.STATUS(jobId)}/cancel`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Accept': 'application/json',\r\n        'Content-Type': 'application/json',\r\n      },\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Cancel failed with status: ${response.status}`);\r\n    }\r\n    \r\n    return await response.json();\r\n    \r\n  } catch (error) {\r\n    console.error('Error canceling job:', error);\r\n    throw new Error(`Cancel failed: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Get job history/list (if backend supports it)\r\nexport const getJobHistory = async (limit = 10, offset = 0) => {\r\n  try {\r\n    const response = await fetch(`${API_ENDPOINTS.JOBS || API_ENDPOINTS.UPLOAD.replace('/upload', '/jobs')}?limit=${limit}&offset=${offset}`, {\r\n      method: 'GET',\r\n      headers: {\r\n        'Accept': 'application/json',\r\n      },\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch job history: ${response.status}`);\r\n    }\r\n    \r\n    return await response.json();\r\n    \r\n  } catch (error) {\r\n    console.error('Error fetching job history:', error);\r\n    throw new Error(`Failed to fetch job history: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Utility function to validate video file\r\nexport const validateVideoFile = async (videoSource) => {\r\n  try {\r\n    const info = await getVideoInfo(videoSource);\r\n    \r\n    if (!info.exists) {\r\n      return { valid: false, error: 'Video file does not exist' };\r\n    }\r\n    \r\n    // Check file size (example: max 100MB)\r\n    const maxSize = 100 * 1024 * 1024; // 100MB\r\n    if (info.size && info.size > maxSize) {\r\n      return { valid: false, error: 'Video file is too large (max 100MB)' };\r\n    }\r\n    \r\n    // Check file type for web\r\n    if (Platform.OS === 'web' && info.type && !info.type.startsWith('video/')) {\r\n      return { valid: false, error: 'Selected file is not a video' };\r\n    }\r\n    \r\n    return { valid: true, info };\r\n    \r\n  } catch (error) {\r\n    return { valid: false, error: error.message };\r\n  }\r\n};\r\n\r\n// Network connectivity check\r\nexport const checkServerConnection = async () => {\r\n  try {\r\n    const response = await fetch(API_ENDPOINTS.HEALTH || API_ENDPOINTS.UPLOAD.replace('/upload', '/health'), {\r\n      method: 'GET',\r\n      timeout: 5000,\r\n    });\r\n    \r\n    return {\r\n      connected: response.ok,\r\n      status: response.status,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      connected: false,\r\n      error: error.message,\r\n    };\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}